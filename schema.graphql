# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

union TypesOrganizationOrOrganizationUserOrUser = Organization | OrganizationUser | User

union TypesOrganizationUserOrUser = OrganizationUser | User

type Address {
  _id: ID
  cep: String
  city: String
  complement: String
  country: String
  createdAt: String
  district: String
  number: String
  state: String
  street: String
  updatedAt: String
  userLocation: UserLocation
}

type AvailableDayAndTime {
  maxTime: AvailableTime
  minTime: AvailableTime
  weekDay: WeekDays
}

type AvailableTime {
  hour: Int
  minutes: Int
}

type CollectionPath {
  _id: ID
  collectionPathResponsibleOrganizationUser: OrganizationUser
  collectionPathStatus: CollectionPathStatus
  collectionPoints: [CollectionPoint]
  createdAt: String
  description: String
  estimatedTimeInMinutes: Int
  name: String
  totalEstimatedDistance: Float
  updatedAt: String
}

type CollectionPoint {
  _id: ID
  collectionPath: CollectionPath
  collectionRequest: CollectionRequest
  createdAt: String
  destination: CollectionPoint
  location: UserLocation
  origin: CollectionPoint
  updatedAt: String
}

type CollectionRequest {
  _id: ID
  acceptedBy: TypesOrganizationOrOrganizationUserOrUser
  canceledOrCompletedBy: TypesOrganizationUserOrUser
  collectionPoint: CollectionPoint
  collectionRequestMaterials: [CollectionRequestMaterial]
  collectionStatus: CollectionStatus
  createdAt: String
  createdBy: User
  details: String
  location: UserLocation
  organization: Organization
  updatedAt: String
}

type CollectionRequestMaterial {
  _id: ID
  amount: Float
  collectionRequest: CollectionRequest
  createdAt: String
  description: String
  materialType: MaterialType
  updatedAt: String
}

type GraphHopperGeocodingLocation {
  city: String
  country: String
  houseNumber: String
  name: String
  osm_id: String
  osm_key: String
  osm_type: String
  point: GraphHopperGeocodingPoint
  postcode: String
  state: String
  street: String
}

type GraphHopperGeocodingPoint {
  lat: Float
  lng: Float
}

type GraphHopperGeocodingResponseSchema {
  hits: [GraphHopperGeocodingLocation]
  took: Int
}

type HereMapsGeocodingAddress {
  city: String
  countryCode: String
  countryName: String
  county: String
  district: String
  houseNumber: String
  label: String
  postalCode: String
  state: String
  stateCode: String
  street: String
}

type HereMapsGeocodingFieldScore {
  city: Int
  houseNumber: Int
  streets: [Int]
}

type HereMapsGeocodingLocation {
  access: [HereMapsGeocodingPosition]
  address: HereMapsGeocodingAddress
  houseNumberType: String
  id: String
  mapView: HereMapsGeocodingMapView
  position: HereMapsGeocodingPosition
  resultType: String
  scoring: HereMapsGeocodingScoring
  title: String
}

type HereMapsGeocodingMapView {
  east: Float
  north: Float
  south: Float
  west: Float
}

type HereMapsGeocodingPosition {
  lat: Float
  lng: Float
}

type HereMapsGeocodingResponseSchema {
  items: [HereMapsGeocodingLocation]
}

type HereMapsGeocodingScoring {
  fieldScore: HereMapsGeocodingFieldScore
  queryScore: Int
}

type Mutation {
  createCollectionPath(createCollectionPathInput: CreateCollectionPathInput): Boolean
  createCollectionRequest(createCollectionRequestInput: CreateCollectionRequestInput): Boolean
  createOrganization(createOrganizationInput: CreateOrganizationInput): OrganizationRegistrationValidation
  createOrganizationUser(createOrganizationUserInput: CreateOrganizationUserInput): OrganizationUserRegistrationValidation
  createUser(createUserInput: CreateUserInput): Boolean
  createUserLocation(createUserLocationInput: CreateUserLocationInput): Boolean
  deleteOrganizationUserById(id: ID): Boolean
  deleteUserLocationById(id: ID!): Boolean
  updateOrganizationUserPersonalData(updateOrganizationUserPersonalDataInput: UpdateOrganizationUserPersonalDataInput): Boolean
  updateUserLocation(updateUserLocationInput: UpdateUserLocationInput): Boolean
  updateUserPassword(updateUserPasswordInput: UpdateUserPasswordInput): String
}

type Organization {
  _id: ID
  collectionRequests: [CollectionRequest]
  cpfCnpj: String
  createdAt: String
  email: String
  isActive: Boolean
  name: String
  organizationType: OrganizationType
  password: String
  updatedAt: String
  users: [OrganizationUser]
}

type OrganizationRegistrationValidation {
  cpfCnpjAlreadyExists: Boolean
  emailAlreadyExists: Boolean
  organizationNameAlreadyExists: Boolean
  passwordConstraintDoesntMatch: Boolean
  registrationSucceeded: Boolean
}

type OrganizationUser {
  _id: ID
  collectionRequests: [CollectionRequest]
  createdAt: String
  email: String
  isActive: Boolean
  name: String
  organization: Organization
  password: String
  responsibleForCollectionPaths: [CollectionPath]
  updatedAt: String
}

type OrganizationUserRegistrationValidation {
  emailAlreadyExists: Boolean
  emailAndOrganizationAlreadyExists: Boolean
  noOrganizationFound: Boolean
  organizationNameAlreadyExists: Boolean
  organizationWithSameNameAlreadyExists: Boolean
  passwordConstraintDoesntMatch: Boolean
  registrationSucceeded: Boolean
}

type Query {
  authenticateOrganization(authenticateOrganizationInput: AuthenticateOrganizationInput): Organization
  authenticateOrganizationUser(authenticateOrganizationUserInput: AuthenticateOrganizationUserInput): OrganizationUser
  authenticateUser(authenticateUserInput: AuthenticateUserInput): User
  findAllCollectionRequestsByUserId(id: ID!): [CollectionRequest]
  findAllCollectionRequestsByUserIdAndIsInStatusArray(id: ID!, statusArray: [CollectionStatus]): [CollectionRequest]
  findAllOrganizationUsers: [OrganizationUser]
  findAllOrganizationUsersByOrganizationId(id: ID!): [OrganizationUser]
  findAllOrganizations: [Organization]
  findAllUserLocationsByUserId(id: ID!): [UserLocation]
  findAllUsers: [User]
  findGeocodingLocation(typedLocation: String): HereMapsGeocodingResponseSchema
  findUserById(id: ID!): User
}

type User {
  _id: ID
  collectionRequests: [CollectionRequest]
  createdAt: String
  email: String
  isActive: Boolean
  locations: [UserLocation]
  name: String
  password: String
  updatedAt: String
}

type UserLocation {
  _id: ID
  address: Address
  availableDaysAndTimes: [AvailableDayAndTime]
  collectionRequests: [CollectionRequest]
  comments: String
  createdAt: String
  latitude: Float
  longitude: Float
  placename: String
  updatedAt: String
  user: User
}

enum CollectionPathStatus {
  CANCELED
  COMPLETED
  IN_DEFINITION
  READY
}

enum CollectionStatus {
  ACCEPTED
  CANCELED
  COMPLETED
  NOT_STARTED
  OPENED
  PAUSED
}

enum MaterialType {
  GLASS
  HAZARDOUS_MATERIALS
  HOSPITAL_WASTE
  METALS
  NON_RECYCLABLE
  ORGANIC_WASTE
  OTHERS
  PAPERS
  PLASTICS
  RADIOACTIVE_MATERIALS
  SEVERALS
  WOODS
}

enum OrganizationType {
  CATADOR
  COOPERATIVA
  EMPRESA_PRIVADA
}

enum WeekDays {
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
}

input AuthenticateOrganizationInput {
  organizationEmail: String!
  password: String!
}

input AuthenticateOrganizationUserInput {
  email: String!
  organizationEmail: String!
  password: String!
}

input AuthenticateUserInput {
  email: String!
  password: String!
}

input AvailableDayAndTimeInput {
  maxTime: AvailableTimeInput
  minTime: AvailableTimeInput
  weekDay: WeekDays
}

input AvailableTimeInput {
  hour: Int
  minutes: Int
}

input CreateCollectionPathInput {
  description: String
  name: String!
  organizationId: ID!
}

input CreateCollectionRequestInput {
  collectionRequestMaterials: [CreateCollectionRequestMaterialInput]!
  details: String
  locationId: ID!
  userId: ID!
}

input CreateCollectionRequestMaterialInput {
  amount: Int
  description: String
  materialType: MaterialType!
}

input CreateOrganizationInput {
  cpfCnpj: String
  email: String!
  name: String!
  organizationType: OrganizationType!
  password: String!
}

input CreateOrganizationUserInput {
  email: String!
  organizationEmail: String!
  password: String!
  username: String!
}

input CreateUserInput {
  email: String!
  name: String!
  password: String!
}

input CreateUserLocationAddressInput {
  cep: String!
  city: String!
  complement: String
  country: String!
  district: String!
  number: String!
  state: String!
  street: String!
}

input CreateUserLocationAvailableDaysAndTimesInput {
  maxTime: CreateUserLocationAvailableTimeInput!
  minTime: CreateUserLocationAvailableTimeInput!
  weekDay: WeekDays!
}

input CreateUserLocationAvailableTimeInput {
  hour: Int!
  minutes: Int!
}

input CreateUserLocationInput {
  address: CreateUserLocationAddressInput!
  availableDaysAndTimes: [CreateUserLocationAvailableDaysAndTimesInput]!
  comments: String
  placename: String!
  userId: ID!
}

input OrganizationUserPersonalDataInput {
  email: String!
  isActive: Boolean!
  name: String!
  password: String!
}

input UpdateOrganizationUserPersonalDataInput {
  _id: String!
  data: OrganizationUserPersonalDataInput!
}

input UpdateUserLocationAddressInput {
  _id: String!
  cep: String!
  city: String!
  complement: String
  country: String!
  district: String!
  number: String!
  state: String!
  street: String!
}

input UpdateUserLocationInput {
  _id: String!
  address: UpdateUserLocationAddressInput
  availableDaysAndTimes: [AvailableDayAndTimeInput]
  comments: String
  placename: String!
}

input UpdateUserPasswordInput {
  email: String!
  newPassword: String!
  oldPassword: String!
}
